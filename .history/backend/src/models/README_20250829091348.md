# Database Models

This directory contains TypeScript models for all database tables in the game store application. Each model provides a clean, type-safe interface for database operations.

## Models Overview

### Core Models
- **Role** - User roles (ADMIN, CUSTOMER)
- **User** - User accounts with authentication and profile information
- **Publisher** - Game publishers/developers
- **Game** - Game information and metadata
- **Genre** - Game genres (Action, RPG, Strategy, etc.)
- **Platform** - Supported platforms (PC, PS5, Xbox, etc.)

### Junction Tables
- **GameGenre** - Many-to-many relationship between games and genres
- **GamePlatform** - Many-to-many relationship between games and platforms

### Business Logic Models
- **Specification** - System requirements (minimum and recommended)
- **Purchase** - Game purchase records
- **Wishlist** - User wishlist items
- **Review** - User reviews and ratings

## Usage Examples

### Basic CRUD Operations

```typescript
import { GameModel, UserModel, PublisherModel } from '../models'

// Get all games with publisher information
const games = await GameModel.findAllWithPublisher()

// Get a specific game with full details
const game = await GameModel.findByIdWithDetails(gameId)

// Create a new game
const gameId = await GameModel.create({
  name: 'New Game',
  price: 59.99,
  publisher_id: 1,
  release_year: 2024
})

// Update a game
const success = await GameModel.update(gameId, { price: 49.99 })

// Delete a game
const deleted = await GameModel.delete(gameId)
```

### Advanced Queries

```typescript
// Get top selling games
const topSelling = await GameModel.findTopSelling(10)

// Get games by genre
const actionGames = await GameModel.findByGenre(genreId)

// Get games by price range
const affordableGames = await GameModel.findByPriceRange(0, 30)

// Search games by name
const searchResults = await GameModel.searchByName('RPG')
```

### Relationship Management

```typescript
import { GameGenreModel, GamePlatformModel } from '../models'

// Set genres for a game
await GameGenreModel.setGenresForGame(gameId, [1, 2, 3]) // Action, RPG, Strategy

// Set platforms for a game
await GamePlatformModel.setPlatformsForGame(gameId, [1, 2]) // PC, PS5

// Check if game has specific genre
const hasAction = await GameGenreModel.gameHasGenre(gameId, actionGenreId)
```

### User Operations

```typescript
import { UserModel, PurchaseModel, WishlistModel, ReviewModel } from '../models'

// Get user with role information
const user = await UserModel.findByIdWithRole(userId)

// Check if user has purchased a game
const hasPurchased = await PurchaseModel.userHasPurchased(userId, gameId)

// Add game to wishlist
await WishlistModel.addToWishlist({ user_id: userId, game_id: gameId })

// Create a review
const reviewId = await ReviewModel.create({
  user_id: userId,
  game_id: gameId,
  rating: 5,
  comment: 'Amazing game!'
})
```

### Statistics and Analytics

```typescript
// Get purchase statistics
const purchaseStats = await PurchaseModel.getPurchaseStats()
const topSelling = await PurchaseModel.getTopSellingGames(10)

// Get review statistics
const reviewStats = await ReviewModel.getReviewStats()
const topRated = await ReviewModel.getTopRatedGames(10)

// Get wishlist statistics
const wishlistStats = await WishlistModel.getWishlistStats()
const mostWished = await WishlistModel.getMostWishedGames(10)
```

## Model Features

### Type Safety
All models use TypeScript interfaces for type safety:
- Input validation for create/update operations
- Proper typing for database results
- Extended interfaces for joined data

### Error Handling
- Consistent error handling patterns
- Transaction support for complex operations
- Graceful fallbacks for missing data

### Performance
- Efficient SQL queries with proper JOINs
- Connection pooling support
- Prepared statements for security

### Extensibility
- Easy to add new methods
- Modular design for maintainability
- Consistent API patterns across models

## Database Schema

The models are designed to work with the following database schema:

```sql
-- Core tables
Role (role_id, name)
User (user_id, username, email, password, age, balance, role_id)
Publisher (publisher_id, name)
Game (game_id, name, release_year, publisher_id, mode, price, multiplayer, capacity, age_rating, average_rating, total_sales, total_revenue)
Genre (genre_id, name)
Platform (platform_id, name)

-- Junction tables
Game_Genre (game_id, genre_id)
Game_Platform (game_id, platform_id)

-- Business logic tables
Specification (spec_id, game_id, type, cpu, ram, gpu, storage)
Purchase (purchase_id, user_id, game_id, purchase_date, price)
Wishlist (wishlist_id, user_id, game_id)
Review (review_id, user_id, game_id, rating, comment, review_date)
```

## Best Practices

1. **Always use models instead of raw SQL** - This ensures type safety and consistency
2. **Handle errors gracefully** - Use try-catch blocks and provide meaningful error messages
3. **Use transactions for complex operations** - Models like GameGenre and GamePlatform support this
4. **Validate input data** - Models include validation for required fields and data types
5. **Use appropriate methods** - Choose the right method for your use case (e.g., `findByIdWithDetails` vs `findById`)

## Adding New Models

To add a new model:

1. Create a new file in the models directory
2. Define TypeScript interfaces for the data structure
3. Implement the model class with static methods
4. Export the model from the index.ts file
5. Update the README with usage examples

## Testing

Models can be tested independently:
- Unit tests for individual methods
- Integration tests with a test database
- Mock data for development and testing

## Performance Considerations

- Use appropriate indexes on the database
- Consider pagination for large result sets
- Cache frequently accessed data when appropriate
- Monitor query performance and optimize as needed
